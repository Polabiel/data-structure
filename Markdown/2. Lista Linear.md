# Lista Linear

Estrutura de dados na qual cada elemento √© precedido por um elemento e sucedido por outro

> exceto o primeiro que n√£o tem predecessor e o √∫ltimo que n√£o tem sucessor.

Os elementos est√£o em uma dada ordem (por exemplo, a ordem de inclus√£o ou ordenados por uma chave).

## Lista Linear Sequecial

√© uma lista linear na qual a ordem l√≥gica dos elementos (a ordem "Vista" pelo usuario) √© a mesma ordem f√≠sica (em mem√≥ria principal) dos elementos.
isto √©, elementos vizinhos na lista estar√£o em posi√ß√µes vizinhas de mem√≥ria.

## Modelagem

Modelaremos usando um `arranjo` de registro;
`Registros` conter√£o as informa√ß√µes de interesse do usu√°rio;
Nosso arranjo ter√° um `tamanho fixo` e controlaremos o n√∫mero de elementos com uma `vari√°vel adicional`.

```c
#define MAX 50

typedef int TIPOCHAVE;

typedef struct {
    TIPOCHAVE chave;
    // outros campos
} REGISTRO;

typedef struct {
    Registro A[MAX];
    int nroElem;
} LISTA;
```

**Implementaremos fun√ß√µes para:**

- Inicializar a estrutura
- Retornar a quantidade de elementos v√°lidos
- Exibir os elementos da estrutura
- Buscar um elemento na estrutura
- Inserir um elemento na estrutura
- Excluir um elemento da estrutura
- Reinicializar a estrutura

## Inicializa√ß√£o

para incializar uma estrutura qualquer, precisamos pensar nos valores adequadados para cada um dos campos de nossa estrutura.
Para inicializar uma lista sequencial j√° criada pelo usu√°rio, s√≥ precisamos colocar o valor 0 (zero) no n√∫mero de elementos v√°lidos.

```c
void inicializarLista(LISTA l) {
    l.nroElem = 0;
}
```

H√° algum problema com este c√≥digo?
Qual a diferen√ßa entre os dois c√≥digos abaixo?

```c
void inicializarLista(LISTA* l) {
    l->nroElem = 0;
}
```

A diferen√ßa √© que no primeiro caso, estamos passando uma c√≥pia da estrutura para a fun√ß√£o, enquanto no segundo caso, estamos passando o endere√ßo da estrutura.

## Retornar n√∫mero de elementos

para retornar o n√∫mero de elementos v√°lidos, basta retornar o valor do campo `nroElem`.

```c
int tamanho(LISTA* l) {
    return l->nroElem;
}
```

## Exibir elementos

para exibir os elementos, basta percorrer o arranjo e exibir os `elementos` v√°lidos.

```c
void exibirLista(LISTA* l) {
    int i;
    printf("Lista: \" ");
    for (i = 0; i < l->nroElem; i++) {
        printf("%i ", l->A[i].chave);
    }
    printf("\"\n");
}
```

## Buscar elemento

A fun√ß√£o de busca dever√°:

- Receber uma chave do usu√°rio
- Retornar a posi√ß√£o em que este elemento se encontra na lista (caso seja encontrado)
- Retornar -1 caso o elemento n√£o seja encontrado

```c
int buscaSequencial(LISTA* l, TIPOCHAVE ch) {
    int i = 0;
    while (i < l->nroElem) {
        if (l->A[i].chave == ch) return i;
        else i++;
    }
    return -1;
}
```

## Inserir elemento

O usu√°rio passa como par√¢metro o elemento a ser inserido na lista.
H√° diferentes possibilidades de inser√ß√£o:

- No in√≠cio da lista
- No final da lista
- Ordenada pela chave
- Numa posi√ß√£o indicada pelo usu√°rio

Vamos utilizar o √∫ltimo caso.

## Como inserir?

Se a lista n√£o estiver cheia e o √≠ndice passado pelo usu√°rio for v√°lido, devemos: `desloca` todos os elementos posteriores uma posi√ß√£o para a direita;
`insere` o elemento na posi√ß√£o deseja, `soma um` no campo nroElem e retorna true
Caso contr√°rio retorna false

```c
bool inserirElemLista(LISTA* l, REGISTRO reg, int i) {
    int j;
    if((l->nroElm == MAX) || (i < 0) || (i > l-> nroLem)) return false;
    for (j = l->nroElem; j > i; j--) l->A[j] = l->A[j-1]
    l->A[i] = reg;
    l->nroElem++;
    return true;
}
```

## Exclus√£o de um elemento

O usu√°rio passa a chave do elemento que ele quer excluir

- Se houver um elemento com esta chave na lista, `"exclui este elemento"`,`descloca` todos os elementos posteriores uma posi√ß√£o para a esquerda, `subtrai um` do campo nroElem e retorna true
- Caso contr√°rio retorna false

```c
bool excluirElemLista(LISTA* l, TIPOCHAVE ch) {
    int pos, j;
    pos = buscaSequencial(l, ch);
    if (pos == -1) return false;
    for (j = pos; j < l->nroElem-1; j++) l->A[j] = l->A[j+1];
    l->nroElem--;
    return true;
}
```

## Reinicializa√ß√£o da estrutura

Para esta estrutura, para reinicializar a lista basta colocar 0 (zero) no campo _nroElem_

```c
void reinicializarEstrutura(LISTA* l) {
    l->nroElem = 0;
}
```

## Otimiza√ß√£o

Buscar produzir uma boa otimiza√ß√£o no projeto para que possa ser mais eficiente

- `Otimiza√ß√£o de busca` por elementos;
- Mudan√ßa na `ordem de inser√ß√£o` dos elementos;

## Busca por elementos

O usu√°rio diz qual elemento √© buscado e a fun√ß√£o retorna a posi√ß√£o desse elemento

- As chaves dos elementos **N√ÉO** est√£o em ordem crescente;
- Se o elemento n√£o existir a fun√ß√£o retornar -1;

Como √© mostrado aqui üëá **(vers√£o inicial)**

```c
int buscaSequencial(LISTA* l, TIPOCHAVE ch) {
    int i = 0;
    while (i < l->nroElem) {
        if (l->A[i].chave == ch) return i;
        else i++;
    }
    return -1;
}
```

#### Ideia

Ao inv√©s de fazer duas compara√ß√µes por itera√ß√£o, seria possivel fazer s√≥ uma?

- Precisamos sempre **comparar a chave do elemento atual** com a chave do elemento buscado;
- Mas como garatir que n√£o iremos **passar do √∫ltimo elemento**
- Garantido que `a chave buscada ser√° encontrada!`

##### Cria√ß√£o de um elemento sentinela

- **Elemento extra** (um registro) adicionado √† lista para auxiliar alguma opera√ß√£o;
- Ser√° **Inserido no final da lista** (ap√≥s o √∫ltimo elemento valido) durante as bucas;
- Conter√° a `chave do elemento buscado.`

```c
int buscaSentinela(LISTA* l, TIPOCHAVE ch) {
    int i = 0;
    l->A[l->nroElem].chave = ch;
    while(l->A[i].chave != ch) i++;
    if(i == l->nroElem) return -1;
    else return i;
}
```

Por√©m h√° um problema

- Se a lista j√° estiver **cheia**, n√£o haver√° espa√ßo para conseguir colocar o **sentinela**;

O que fazer?

- Criar a lista com uma posi√ß√£o extra (**um registro a mais**) para garantir que haver√° espa√ßo para o sentinela
- Essa posi√ß√£o extra **nunca ter√° um registro valido**

> Obs: al√©m disso a posi√ß√£o extra √© uma posi√ß√£o que nunca ser√° exibida, at√© por qu√™ ela √© colocada na ultima posi√ß√£o onde **nenhum** outro elemento da lista ter√° acesso.

##### Modelagem (Atualizada)

```c
#define MAX 50

typedef int TIPOCHAVE;

typedef struct {
    TIPOCHAVE chave;
    // outros campos
} REGISTRO;

typedef struct {
    REGISTRO A[MAX+1];
    int nroElem;
} LISTA;
```

Mas a **Busca bin√°ria** n√£o seria mais eficiente?

- `Sim`, por√©m ela necessita que as chaves dos elementos estejam **ordenadas**;

Para isso, precisaremos mudar nossa fun√ß√£o de **inser√ß√£o de elementos**.

- A fun√ß√£o de inser√ß√£o de elementos seguir√° a l√≥gica do `insert sort`.

## Inser√ß√£o ordenada (insert sort)

Agora √© a parte que a filha chora, e a m√£e n√£o v√™

- A fun√ß√£o de inser√ß√£o de elementos seguir√° a l√≥gica do `insert sort`.

```c
bool inserirElemListaOrd(LISTA* l, REGISTRO reg) {
    if(l->nroElem >= MAX) return false;
    int pos = l->nroElem;
    while(pos > 0 && l->A[pos-1].chave > reg.chave) {
        l->A[pos] = l->A[pos-1];
        pos--;
    }
    l->A[pos] = reg;
    l->nroElem++;
}
```

### Explica√ß√£o do c√≥digo

Temos uma lista passada como par√¢metro e um registro que ser√° inserido na lista.

e o usuario quer inserir o elemento `33`

a posi√ß√£o come√ßa com um n√∫mero de elementos da lista `A = [5, 9, 44]` e `nroElem = 3`

Ent√£o ele verifica o `pos > 0` e verifica se o elemento da posi√ß√£o anterior √© maior que o elemento que ele quer inserir

> lembrando: que o valor do pos √© a quantidade de elementos dentro da lista

Depois v√™ se da ultima posi√ß√£o da lista √© maior que o elemento que ele quer inserir, caso seja ele vai deslocando os elementos para a direita, at√© que o elemento da posi√ß√£o anterior seja menor que o elemento que ele quer inserir

e depois ele insere o elemento na posi√ß√£o que ele parou

> A lista ficaria assim: `A = [5, 9, 33, 44]` e `nroElem = 4`

![Imagem de Exemplo](image.png)

## Busca bin√°ria

- A busca bin√°ria √© um algoritmo de busca em vetores que segue o paradigma de divis√£o e conquista.

- Ela parte do pressuposto de que o vetor est√° ordenado e realiza sucessivas divis√µes do espa√ßo de busca comparando o elemento buscado (chave) com o elemento no meio do vetor.

```c
int buscaBinaria(LISTA* l, TIPOCHAVE ch) {
    int esq, dir, meio;
    esq = 0;
    dir = l->nroElem-1;

    while(esq<= dir) {
        meio = ((esq+dir)/2);
        if(l->A[meio].chave == ch) return meio;
        else {
            if(l->A[meio].chave < ch) esq = meio+1;
            else dir = meio-1;
        }
    }
    return -1;
}
```

## Elementos ordenandos pelas chaves

Com a ordena√ß√£o dos elementos pela chave:

- A **busca** ficou **mais eficiente** (busca bin√°ria);
- N√£o precisamos do **sentila**;
- O que acontece com a `exclus√£o`?

## Exclus√£o de elementos

- A exclus√£o de elementos n√£o √© t√£o simples quanto a inser√ß√£o;
- Precisamos **encontrar** o elemento a ser exclu√≠do;
- **Deslocar** todos os elementos posteriores uma posi√ß√£o para a esquerda;
- **Subtrair um** do campo nroElem e retornar true;

```c
bool excluirElemLista(LISTA* l, TIPOCHAVE ch) {
    int pos, j;
    pos = buscaBinaria(l, ch);
    if (pos == -1) return false;
    for (j = pos; j < l->nroElem-1; j++) l->A[j] = l->A[j+1];
    l->nroElem--;
    return true;
}
```